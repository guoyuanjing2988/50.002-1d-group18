module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    input cclk,             // configuration clock, AVR ready when high
    output spi_miso,        // AVR SPI MISO
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR SPI Clock
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
    input avr_tx,           // AVR TX (FPGA RX)
    output avr_rx,          // AVR RX (FPGA TX)
    input avr_rx_busy,      // AVR RX buffer full
    output io_led [3][8],   // LEDs on IO Shield
                            // io_led[0] correspond to input a, io_led[1] correspond to input b, io_led[2] correspond to output c.
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8]     // DIP switches on IO Shield
                            // io_dip[0] correspond to input a, io_dip[1] correspond to input b, io_dip[3] correspond to input ALUFN.
  ) {
  
  sig rst;                  // reset signal
  


  eightbitadder adder;
  eightbitsubtracter subtracter;
  eightbitand andd;
  eightbitor orr;
  eightbitxor xorr;
  eightbitequalsa equalsa;
  eightbitshiftleft shiftleft;
  eightbitshiftright shiftright;
  eightbitSRA sra;
  eightbitCMPEQ cmpeq;
  eightbitCMPLT cmplt;
  eightbitCMPLE cmple;
  var z;
  var v;
  var n;
  var x,y;
  var i;
  sig a[8];
  sig b[4];
  always {
    
    spi_miso = bz;            // not using SPI
    spi_channel = bzzzz;      // not using flags
    avr_rx = bz;              // not using serial port
    
    
    
    
    //using io_dip[2][0:5] as ALUFN[0:5], which are 3rd switch to 8th switch.
    
    
    adder.a=io_dip[0];
    adder.b=io_dip[1];
    z=adder.z;
    v=adder.v;
    n=adder.n;
    subtracter.a=io_dip[0];
    subtracter.b=io_dip[1];
    andd.a=io_dip[0];
    andd.b=io_dip[1];
    orr.a=io_dip[0];
    orr.b=io_dip[1];
    xorr.a=io_dip[0];
    xorr.b=io_dip[1];
    equalsa.a=io_dip[0];
    equalsa.b=io_dip[1];
    shiftleft.a=io_dip[0];
    shiftleft.b=io_dip[1];
    shiftright.a=io_dip[0];
    shiftright.b=io_dip[1];
    sra.a=io_dip[0];
    sra.b=io_dip[1];
    cmpeq.z=z;
    cmplt.v=v;
    cmplt.n=n;
    cmple.z=z;
    cmple.v=v;
    cmple.n=n;
    x=0;
    y=1;
    for (i=0;i<6;i++){
      x=x+(y*io_dip[2][i]);
      y=y*2;
    }
    a=0;
    case (x){
    
      0: a=adder.out;
      1: a=subtracter.out;
      24: a=andd.out;
      30: a=orr.out;
      22: a=xorr.out;
      26: a=equalsa.out;
      32: a=shiftleft.out;
      33: a=shiftright.out;
      35: a=sra.out;
      51: a=cmpeq.out;
      53: a=cmplt.out;
      55: a=cmple.out;
    }
    io_led[2]=a;
    x=0;
    y=1;
    for (i=0;i<8;i++){
      x=x+y*a[i];
      y=y*2;
    }
    io_led[0] = io_dip[0];   // connect the DIP switches to the LEDs
    io_led[1] = io_dip[1];
  }    
}